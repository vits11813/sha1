export = Token;
/**
 * @typedef {import('../util/Types').JwtHeader} JwtHeader
 * @typedef {import('../util/Types').JwtPayload} JwtPayload
 */
/**
 * @typedef {object} DecodeCacheConfig
 * @property {Number} [size] - Size of the cache, defaults to 100
 * @property {import("../util/Types").Cache} [impl] - A custom cache instance that is used instead of the default LRUCache.
 */
declare class Token {
    /**
     * A shared jwt->{header, payload} cache that is used to avoid decoding the same token multiple times.
     * @type {import("../util/Types").Cache}
     */
    static decodeCache: import("../util/Types").Cache;
    /**
     * Enables the shared decode cache for tokens.
     * @param {DecodeCacheConfig} [config] - Optional configuration for the decode cache.
     */
    static enableDecodeCache(config?: DecodeCacheConfig): void;
    /**
     * Disables the shared decode cache for tokens.
     */
    static disableDecodeCache(): void;
    /**
     * @param {string|null} jwt
     * @param {object} [content] - optional decoded content
     * @param {JwtHeader & { [key: string]: any }} [content.header] - Optional parsed header (used instead of decoding jwt parameter if both header/payload are provided)
     * @param {JwtPayload & { [key: string]: any }} [content.payload] - Optional parsed payload (used instead of decoding jwt parameter if both header/payload are provided)
     */
    constructor(jwt: string | null, { header, payload }?: {
        header?: JwtHeader & {
            [key: string]: any;
        };
        payload?: JwtPayload & {
            [key: string]: any;
        };
    });
    get audiences(): string[];
    get azp(): string;
    /**
     * @returns {string|null} clientId used to fetch the token
     */
    get clientId(): string | null;
    get email(): string;
    /**
     * Returns whether the token is expired based on claim exp (expiration time).
     * There is a 1min leeway after the exp in which the token still counts as valid to account for clock skew.
     * @return {Boolean} false if token has a positive {@link remainingTime}, true otherwise
     */
    get expired(): boolean;
    get expirationDate(): Date;
    /**
     * @returns {string|null} family name of the user
     */
    get familyName(): string | null;
    /**
     * @returns {string|null} first name of the user
     */
    get givenName(): string | null;
    get grantType(): string;
    /** @return {JwtHeader} Token header as parsed object */
    get header(): JwtHeader;
    get issuer(): string;
    get issueDate(): Date;
    /** @return {String} JWT used to construct this Token instance as raw String */
    get jwt(): string;
    /**
     * Returns whether the token is not yet valid based on the optional nbf (no use before) claim.
     * There is a 1min leeway before the nbf in which the token already counts as valid to account for clock skew.
     * @return {Boolean} true if token has valid nbf date that lies at least one minute in the future, false otherwise
     * @throws InvalidJwtError when nbf claim exists but is not a valid timestamp value
     */
    get notYetValid(): boolean;
    get origin(): any;
    /** @return {JwtPayload} Token payload as parsed object */
    get payload(): JwtPayload;
    /**
     * Returns the remaining time until expiration in seconds based on claim exp (expiration time).
     * There is a 1min leeway after the exp in which the token still counts as valid to account for clock skew.
     * @returns seconds until expiration or 0 if expired
     * @throws InvalidJwtError when exp claim does not have a valid value
     */
    get remainingTime(): number;
    get subject(): string;
    get userName(): string;
    get userId(): string;
    getAudiencesArray(): string[];
    getAzp(): string;
    getClientId(): string;
    getEmail(): string;
    getExpirationDate(): Date;
    getFamilyName(): string;
    getGivenName(): string;
    getGrantType(): string;
    getHeader(): import("../util/Types").JwtHeader;
    getIssuedAt(): Date;
    getIssuer(): string;
    getPayload(): import("../util/Types").JwtPayload;
    getSubject(): string;
    getTokenValue(): string;
    getUserId(): string;
    #private;
}
declare namespace Token {
    export { JwtHeader, JwtPayload, DecodeCacheConfig };
}
type JwtHeader = import("../util/Types").JwtHeader;
type JwtPayload = import("../util/Types").JwtPayload;
type DecodeCacheConfig = {
    /**
     * - Size of the cache, defaults to 100
     */
    size?: number;
    /**
     * - A custom cache instance that is used instead of the default LRUCache.
     */
    impl?: import("../util/Types").Cache;
};
//# sourceMappingURL=Token.d.ts.map