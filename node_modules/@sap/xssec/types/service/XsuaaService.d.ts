export = XsuaaService;
/**
 * @typedef {import('../util/Types').ServiceCredentials} ServiceCredentials
 * @typedef {import('../util/Types').XsuaaServiceCredentials} XsuaaServiceCredentials
 * @typedef {import('../util/Types').ServiceConfig} ServiceConfig
 * @typedef {import('../util/Types').SecurityContextConfig} SecurityContextConfig
 * @typedef {import('../util/Types').TokenFetchOptions} TokenFetchOptions
 * @typedef {import('../util/Types').XsuaaTokenFetchOptions} XsuaaTokenFetchOptions
 * @typedef {import('../util/Types').TokenFetchResponse} TokenFetchResponse
 * @typedef {import('../util/Types').RefreshableTokenFetchResponse} RefreshableTokenFetchResponse
 * @typedef {import('../util/Types').GrantType} GrantType
 */
/**
 * New SAP BTP applications should start with SAP Identity Services instead of XSUAA! See README for details.\
 * This {@link Service} class is constructed from XSUAA credentials to provide an API with selected functionality against that XSUAA service instance, e.g. token validation and token fetches.
 */
declare class XsuaaService extends Service {
    /**
     * @param {ServiceCredentials & XsuaaServiceCredentials} credentials
     * @param {ServiceConfig} [serviceConfig={}]
     */
    constructor(credentials: ServiceCredentials & XsuaaServiceCredentials, serviceConfig?: ServiceConfig);
    /**
     * @overrides
     * @inheritdoc
     */
    acceptsTokenAudience(token: any): boolean;
    /**
     * @override
     * @param {String|XsuaaToken} token as JWT or XsuaaToken object
     * @param {SecurityContextConfig} contextConfig
     * @returns {Promise<XsuaaSecurityContext}
     */
    override createSecurityContext(token: string | XsuaaToken, contextConfig?: SecurityContextConfig): Promise<XsuaaSecurityContext>;
    getJwks(token: any, contextConfig: any): Promise<any>;
    /**
     * @internal
     * Returns the base URL (https protocol + uaadomain from the credentials) that can be used for JWKS fetches.
     * @returns {String} base URL for JWKS fetches
     */
    get jwksBaseUrl(): string;
    fetchJwks(jwksParams: any, correlationId: any): Promise<any>;
    /**
     * Fetches a token from this service with this service's client credentials.
     * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
     * @returns {Promise<TokenFetchResponse>} response
     */
    fetchClientCredentialsToken(options?: TokenFetchOptions & XsuaaTokenFetchOptions): Promise<TokenFetchResponse>;
    /**
     * Fetches a user token from this service with the given username and password.
     * @param {String} username
     * @param {String} password
     * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
     * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
     */
    fetchPasswordToken(username: string, password: string, options?: TokenFetchOptions & XsuaaTokenFetchOptions): Promise<TokenFetchResponse & RefreshableTokenFetchResponse>;
    /**
     * Fetches a JWT bearer token from this service with the given user token as assertion.
     * @param {String} assertion JWT bearer token used as assertion
     * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
     * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
     */
    fetchJwtBearerToken(assertion: string, options?: TokenFetchOptions & XsuaaTokenFetchOptions): Promise<TokenFetchResponse & RefreshableTokenFetchResponse>;
    /** @override */
    override buildTokenRequest(grant_type: any, options: any): {
        checkServerIdentity?: ((hostname: string, cert: import("tls").DetailedPeerCertificate) => Error | undefined) | undefined;
        rejectUnauthorized?: boolean | undefined;
        servername?: string | undefined;
        _defaultAgent?: import("http").Agent | undefined;
        agent?: import("http").Agent | boolean | undefined;
        auth?: string | null | undefined;
        createConnection?: ((options: import("http").ClientRequestArgs, oncreate: (err: Error | null, socket: import("stream").Duplex) => void) => import("stream").Duplex | null | undefined) | undefined;
        defaultPort?: number | string | undefined;
        family?: number | undefined;
        headers?: import("http").OutgoingHttpHeaders | readonly string[] | undefined;
        host?: string | null | undefined;
        hostname?: string | null | undefined;
        insecureHTTPParser?: boolean | undefined;
        localAddress?: string | undefined;
        localPort?: number | undefined;
        lookup?: import("net").LookupFunction | undefined;
        maxHeaderSize?: number | undefined;
        method?: string | undefined;
        path?: string | null | undefined;
        port?: number | string | null | undefined;
        protocol?: string | null | undefined;
        setDefaultHeaders?: boolean | undefined;
        setHost?: boolean | undefined;
        signal?: AbortSignal | undefined;
        socketPath?: string | undefined;
        timeout: number | undefined;
        uniqueHeaders?: Array<string | string[]> | undefined;
        joinDuplicateHeaders?: boolean | undefined;
        hints?: number | undefined;
        ALPNCallback?: ((arg: {
            servername: string;
            protocols: string[];
        }) => string | undefined) | undefined;
        allowPartialTrustChain?: boolean | undefined;
        ca?: string | Buffer | Array<string | Buffer> | undefined;
        cert?: string | Buffer | Array<string | Buffer> | undefined;
        sigalgs?: string | undefined;
        ciphers?: string | undefined;
        clientCertEngine?: string | undefined;
        crl?: string | Buffer | Array<string | Buffer> | undefined;
        dhparam?: string | Buffer | undefined;
        ecdhCurve?: string | undefined;
        honorCipherOrder?: boolean | undefined;
        key?: string | Buffer | Array<string | Buffer | import("tls").KeyObject> | undefined;
        privateKeyEngine?: string | undefined;
        privateKeyIdentifier?: string | undefined;
        maxVersion?: import("tls").SecureVersion | undefined;
        minVersion?: import("tls").SecureVersion | undefined;
        passphrase?: string | undefined;
        pfx?: string | Buffer | Array<string | Buffer | import("tls").PxfObject> | undefined;
        secureOptions?: number | undefined;
        secureProtocol?: string | undefined;
        sessionIdContext?: string | undefined;
        ticketKeys?: Buffer | undefined;
        sessionTimeout?: number | undefined;
        retry: boolean | import("../util/Types").RetryConfig;
    };
    /**
     * Determines the URL that can be used for fetching tokens from this service, optionally adjusted for a tenant in the same subaccount.
     * @override
     * @inheritdoc
     * @param {GrantType} grant_type
     * @param {String} options.tenant
     */
    override getTokenUrl(grant_type: GrantType, options?: {}): Promise<URL>;
    #private;
}
declare namespace XsuaaService {
    export { ServiceCredentials, XsuaaServiceCredentials, ServiceConfig, SecurityContextConfig, TokenFetchOptions, XsuaaTokenFetchOptions, TokenFetchResponse, RefreshableTokenFetchResponse, GrantType };
}
import Service = require("./Service");
import XsuaaToken = require("../token/XsuaaToken");
import XsuaaSecurityContext = require("../context/XsuaaSecurityContext");
type ServiceCredentials = import("../util/Types").ServiceCredentials;
type XsuaaServiceCredentials = import("../util/Types").XsuaaServiceCredentials;
type ServiceConfig = import("../util/Types").ServiceConfig;
type SecurityContextConfig = import("../util/Types").SecurityContextConfig;
type TokenFetchOptions = import("../util/Types").TokenFetchOptions;
type XsuaaTokenFetchOptions = import("../util/Types").XsuaaTokenFetchOptions;
type TokenFetchResponse = import("../util/Types").TokenFetchResponse;
type RefreshableTokenFetchResponse = import("../util/Types").RefreshableTokenFetchResponse;
type GrantType = import("../util/Types").GrantType;
//# sourceMappingURL=XsuaaService.d.ts.map