const cds = require('../../lib/cds')
const { path } = cds.utils
const { join } = path
const { execSync } = require('node:child_process')
const { highlight } = require('../../lib/util/term')

const buildpacks = new Set([
  'java', 'nodejs', 'sap-machine', 'executable-jar', 'spring-boot', 'syft'
])
const builders = new Set([
  'builder-jammy-base', 'builder-jammy-buildpackless-base', 'builder-jammy-full', 'builder-jammy-buildpackless-full'
])

const keyProcessorMap = {
  dockerfile: processDockerfile,
  commands: processCommands,
  buildpack: processBuildpack
}

const run = cmd => {
  cmd = Array.isArray(cmd) ? cmd.join(' ') : cmd
  console.log(highlight(cmd))
  try {
    return execSync(cmd, {
      stdio: 'inherit',
      env: { ...process.env, FORCE_COLOR: cds.utils.colors.enabled }
    })
  } catch (error) {
    throw error.message
  }
}

function appendSubcommand(param, subcommand) {
  if (!param) return []
  if (subcommand === '--env') {
    return Object.entries(param).flatMap(([k, v]) =>
      String(v).split(',').map(env => [subcommand, `${k}=${env.trim() || '""'}`])
    ).flat()
  }
  return param.split(',').map(e => [subcommand, e.trim()]).flat()
}

function processDockerfile(bp, name, tag) {
  if (!bp.dockerfile) return []
  return [['docker', 'build',
    ...appendSubcommand(`${name}:${tag ?? 'latest'}`, '-t'),
    ...appendSubcommand(bp.dockerfile, '-f'),
    '.']]
}

function processCommands(bp) {
  return bp.commands ? bp.commands.map(c => c.trim().split(' ')) : []
}
function processBuildpack(bp, name, tag, clearCache = false) {
  let { type, path, env, builder } = bp.buildpack
  type = type ? type.split(',').map(t => buildpacks.has(t.trim()) ? `paketo-buildpacks/${t.trim()}` : t.trim()) : []
  if (builders.has(builder)) builder = `paketobuildpacks/${builder}`
  const cacheArgs = clearCache ? ['--clear-cache'] : []
  return [['pack',
    ...appendSubcommand(`${name}:${tag}`, 'build'),
    ...appendSubcommand(path, '--path'),
    ...type.flatMap(t => appendSubcommand(t, '--buildpack')),
    ...appendSubcommand(builder, '--builder'),
    ...appendSubcommand(env, '--env'),
    ...cacheArgs
  ]]
}

/**
 * Parses a YAML configuration file to extract Docker build and push commands for modules.
 *
 * @param {string} filename - The path to the YAML file to parse.
 * @param {string} [repoOpt=''] - Optional repository override. If not provided, uses the repository defined in the YAML file.
 * @param {boolean} [clearCache=false] - Whether to clear cache for buildpack builds.
 * @returns {{
 *   commands: Array<{
 *     name: string,
 *     tag: string,
 *     buildCmd: Array<string>,
 *     tagCmd: Array<string>,
 *     pushCmd: Array<string>
 *   }>,
 *   before_all: Array<Array<string>>,
 *   repository: string
 * }} An object containing the commands for each module, any global pre-commands, and the repository name.
 * @throws {Error} If modules are not defined in the YAML file or if build-parameters are invalid.
 */
function parseYAML(filename, repoOpt = '', options) {
  const file = cds.load.yaml(join(cds.root, filename))
  const { repository: repoFile, modules, tag: globalTag = 'latest' } = file
  const repository = repoOpt || repoFile
  const before_all = file['before-all'] ? file['before-all'].map(c => c.trim().split(' ')) : []
  if (!modules) throw new Error('Modules not defined')
  console.log(`Using repository: ${repository}`)
  const commands = modules.map(m => {
    const name = m.name, tag = m.tag || globalTag, bp = m['build-parameters']
    const source = `${name}:${tag}`, repoImg = `${repository}/${source}`
    const key = Object.keys(bp)[0]
    const buildType = keyProcessorMap[key]
    if (!buildType) throw new Error(`build-parameters ${Object.keys(bp)} is invalid.`)
    return {
      name, tag,
      buildCmd: key === 'buildpack'
        ? buildType(bp, name, tag, options.clearCache)
        : buildType(bp, name, tag),
      tagCmd: ['docker', 'tag', source, repoImg],
      pushCmd: ['docker', 'push', repoImg]
    }
  })
  return { commands, before_all, repository }
}

/**
 * Executes the containerization commands for each module.
 * @param {*} modules - The list of modules with their respective build, tag, and push commands.
 * @param {*} options - Options object, e.g., { push: true } to push images after building.
 */
async function executeModules(modules, options) {
  for (const m of modules) {
    console.log(`Containerising module ${m.name}`)
    for (const cmd of m.buildCmd) run(cmd)
    if (options.push) {
      run(m.tagCmd)
      run(m.pushCmd)
    }
  }
}

/**
 * Main function to containerize modules based on a YAML configuration file.
 * @param {string} filename - The path to the YAML configuration file.
 * @param {{ push: boolean, clearCache: boolean }} options - Options object, e.g., { push: true } to push images after building.
 * @returns {Promise<void>}
 */
async function containerize(filename, options = { push: false, clearCache: false }) {
  const { repository, before_all, commands: modules } = parseYAML(filename, '', options)
  if (!repository || !modules) return
  for (const cmd of before_all) await run(cmd)
  await executeModules(modules, options)
}

module.exports = { containerize }
