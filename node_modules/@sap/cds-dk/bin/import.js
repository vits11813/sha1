module.exports = Object.assign(_import, {
    _name: 'import',
    options:   [ '--services', '--for', '--out', '--as', '--name', '--include-namespaces', '--dependencies', '--from', '--config', '--destination', '--group', '--data-product' ],
    shortcuts: [ '-s', '-4',    '-o',    '-as',  '-n',     '-ns',                    '-d',            undefined,  '-c',       undefined,       undefined, '-', '-f'],
    flags: [ '--dry', '--force', '--no-copy', '--no-save', '--keep-namespace', '--data-product', '--edmx', '--rfc', '--odata', '--openapi', '--asyncapi' ],
    help: `
# SYNOPSIS

    *cds import* <source> [<options>]

    Imports the given source and converts it to CSN.
    Currently following file formats are supported.
    - EDMX and XML for OData V2 and V4
    - JSON for OpenAPI and AsyncAPI

    Without any options the source is copied to ./srv/external and the csn
    output written next to it. Finally it will add an entry for the imported
    service to package.json#cds.requires.


# OPTIONS

    *--no-copy*
        Skips copying to ./srv/external.

    *--no-save*
        Skips updating ./package.json.

    *-o | --out* <filename/dirname>
        Skips copying to ./srv/external and writes to the specified location.

    *- | --dry*
        Writes the converted csn to stdout only.

    *-as | --as <output_file_format>*
        Converts the input file into one of these supported formats "cds", "csn"
        or "json".

    *-f | --force*
        Forcefully overwrites the contents in the CDS file and updates the
        checksum

    *--from*
        Imports the model from the one of the given options "edmx", "openapi" or
        "asyncapi".

    *-c | --config* <JSON string | comma-separated key-value pairs>
        Adds the provided JSON or key-value pairs to the configuration.

    *-4 | --for* <profile>

      Write configuration data for the given profile.

    *--destination*
        Destination name under which the remote service can be reached.
        Not supported by import types "edmx", "openapi" or "asyncapi".

    *--data-product*
        Tells cds import to import a data product. The source must be a valid 
        data product CSN file, e.g. as found on http://api.sap.com/dataproducts.
        (Not released with general availability yet)

    *Below options are valid for OData only*

    *--keep-namespace*
        Keeps the original namespace from the edmx content instead of using
        the filename by default.

    *-ns | --include-namespaces <string_of_namespaces> or* "\x2A"
        Imports only entities matching to the given list of namespaces.
        For OData V2 attributes with the namespace "sap" & "m" are captured by
        default.

    *-d | --dependencies* <comma-separated list of dependencies>
        Imports the given list of dependencies along with the main file. Valid for OData V4 only.
        The dependencies are written to the given dirname(-o option) or ./srv/external.
        If the cds files of dependencies are already present in the destination, it will be skipped
        if -f option is not given.
        NOTE: The dependencies must not have any dependency.

    *Below options are valid for RFC only*

    *-n | --name*
        The name of the module to be imported
        Requires valid system credentials as the import connects to the system to fetch the metadata.

    *--group*
        Logical group under which the remote service is imported and registered. This could be a
        function group or an application component name. Defaults to the destination name.

# EXAMPLES

    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx
    cds import - ~/Downloads/API_BUSINESS_PARTNER.edmx
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --from edmx --as cds
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --include-namespaces "sap,c4c"
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --include-namespaces "\x2A"
    cds import ~/Downloads/sap.graph.edmx -d ./sap.c4c.edmx,./sap.s4.edmx --as cds -o ./graph
    cds import ~/Downloads/Petstore_OpenAPI.json
    cds import ~/Downloads/Petstore_OpenAPI.json --from openapi
    cds import ~/Downloads/BookStore_AsyncAPI.json
    cds import ~/Downloads/BookStore_AsyncAPI.json --from asyncapi
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx -c "{\\"[production]\\":{\\"credentials\\":{\\"destination\\":\\"UI3_noauth\\",\\"path\\":\\"/sap/cap/odata\\"}}}"
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --for sandbox    -c "destination.properties.url=https://sandbox.api.sap.com/s4hanacloud/sap/opu/odata/sap"
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --for production -c "http.suffix=/sap/opu/odata/sap,http.csrf.enabled=true"

`})

async function _import(args, options = {}) {
    const messages = require('../lib/import/message').getMessages();
    const common = require('../lib/import/common');
    const cds = require('../lib/index');

    // check if dependencies are provided and import them first
    if (options.dependencies) {
        const dependencies = options.dependencies.split(',');
        delete options.dependencies;
        for (let dependency of dependencies) {
            const o = structuredClone(options);
            o.isDependency = true;
            if (dependency) await _import(dependency, o);
        }
        options.isDependent = true;
    }

    await cds.plugins
    const cwd = process.cwd();

    if (options['data-product']) {
        const import_ = require ('./data-products/import.js')
        return import_.exec (this)
    }

    // process options
    const apiOptions = {};
    await common.processOptions(options, apiOptions);

    const file = Array.isArray(args) ? args[0] : args
    let input = file
    if (!options.name) { // if no --name is given, use the positional file argument
        if (!file) return this.help('import')
        input = await common.preProcess(file, options, cwd);
    }

    if (input) {
        const fileType = await common.identifyFile(input);
        if ((options.isDependency || options.isDependent) && fileType !== 'edmx') {
            throw messages.DEPENDENCY_NOT_SUPPORTED;
        }
    }

    let csn
    if (options.edmx) options.from = 'edmx'
    else if (options.odata) options.from = 'edmx'
    else if (options.openapi) options.from = 'openapi'
    else if (options.asyncapi) options.from = 'asyncapi'
    else if (options.rfc) options.from = 'rfc'
    if (options.from) {
        if (!cds.import.from[options.from]) {
            // the required plugin might not be installed, e.g. rfc importer
            throw messages.UNSUPPORTED_FROM_OPTION.replace('{0}', options.from).replace('{1}', Object.keys(cds.import.from).join(', '));
        }
        csn = await cds.import.from[options.from](input, apiOptions);
    } else {
        csn = await cds.import(input, apiOptions);
    }

    // reads the file version
    options.inputFileKind = apiOptions.odataVersion ? apiOptions.odataVersion : apiOptions.inputFileKind;

    // postprocess
    return common.postProcess(apiOptions.file ?? file, options, csn, cwd);
}
