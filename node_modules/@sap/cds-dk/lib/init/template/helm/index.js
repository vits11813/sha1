const { join } = require('path')
const cds = require('../../../cds')
const { readFileSync, exists, rimraf, copy, yaml } = cds.utils
const { readProject } = require('../../projectReader')
const { merge } = require('../../merge')
const { ask4 } = require('../../../util/question')
const { execSync } = require('child_process')
const { mvn } = require('../../add')

module.exports = class HelmTemplate extends require('../../plugin') {

    static help() {
        return 'Kyma deployment using Helm charts'
    }

    options() {
        return {
            'y': {
                type: 'boolean',
                help: 'If provided, the default values will be used for all prompts.'
            }
        }
    }

    async canRun() {
        const hasInProduction = HelmTemplate.hasInProduction()
        if (cds.cli.options.force) {
            await rimraf(join('chart'))
            return true
        } else if (exists(join(cds.root, 'chart')) && !hasInProduction) {
            throw `Chart already exists. Use --force to overwrite.`
        }
        return true
    }

    // Won't need this any more with plugin approach: package not there -> plugin not pulled
    static hasInProduction() {
        if (exists('chart/Chart.yaml')) {
            const chartYaml = yaml.parse(readFileSync(join(cds.root, 'chart', 'Chart.yaml'), 'utf8'))
            return chartYaml.annotations?.["app.kubernetes.io/managed-by"] === 'cds-dk/helm'
        }
        return false
    }

    async run() {
        const project = readProject()
        let imagePullSecret, registry, domain, tag
        if (!HelmTemplate.hasInProduction() && !project.isBas /* don't run this for the BAS Yeoman generator */) {
            try {
                const domainGuess = execSync(`kubectl config view --minify --output jsonpath="{.clusters[*].cluster.server}"`, { stdio: "pipe" }).toString()
                const domainStartIndex = domainGuess.indexOf('api.')
                if (domainStartIndex !== -1) domain = domainGuess.substring(domainStartIndex + 4)
            } catch (error) { /* ignore */ }

            if (exists('containerize.yaml')) {
                const { repository: r, tag: t } = yaml.parse(join(cds.root, 'containerize.yaml'))
                if (r) registry = r
                if (t) tag = t
            }
            if (!cds.cli.options.y && !cds.cli.options.force) {
                registry ??= await ask4(`registry server: `)
                domain ??= await ask4(`cluster domain: `)
            }
        }
        project.registry = registry ?? '<registry-server>'
        project.domain = domain ?? '<cluster-domain>'
        project.imagePullSecret = imagePullSecret ?? 'docker-registry'
        project.tag = tag ?? 'latest'
        await copy(join(__dirname, 'files', 'values.schema.json')).to('chart/values.schema.json')
        await merge(__dirname, 'files/Chart.yaml.hbs').into('chart/Chart.yaml', { with: project })
        await merge(__dirname, 'files/values.yaml.hbs').into('chart/values.yaml', { with: project })
        await this._mergeDependency('web-application', 'srv')
        if (project.isJava) await mvn.add('k8s')
    }

    async combine() {
        // REVISIT: This must be moved to the respective plugins
        const {
            addHana, addMultitenancy, addXsuaa,
            addApprouter, addIas, addAms, hasXsuaa, hasMultitenancy,
            addDestination, addEnterpriseMessaging, addEnterpriseMessagingShared, addHtml5Repo, hasHtml5Repo, addKafka, addAttachments, addPortal, addMalwareScanner,
            addDynatrace, addCloudLogging, addAuditLogging,
        } = readProject()

        if (addApprouter) {
            await this._mergeDependency('web-application', 'approuter')
        }

        if (addHtml5Repo || addApprouter && hasHtml5Repo) {
            if (addHtml5Repo) {
                await this._mergeDependency('service-instance', 'html5-apps-repo-host')
                await this._mergeDependency('content-deployment', 'html5-apps-deployer')
            }
            if (addApprouter) {
                await this._mergeDependency('service-instance', 'html5-apps-repo-runtime')
            }
        }
        if (addMultitenancy || addXsuaa || addIas || addAms) {
            if (addMultitenancy) {
                await this._mergeDependency('web-application', 'sidecar')
            }
            if (hasXsuaa && hasMultitenancy) {
                await this._mergeDependency('service-instance', 'saas-registry')
            } else if (hasMultitenancy) {
                await this._mergeDependency('service-instance', 'subscription-manager')
            }
        }
        if (addDestination) {
            await this._mergeDependency('service-instance', 'destination')
        }
        if (addAttachments) {
            await this._mergeDependency('service-instance', 'attachments')
        }
        if (addEnterpriseMessaging || addEnterpriseMessagingShared) {
            await this._mergeDependency('service-instance', 'event-mesh')
        }
        if (addXsuaa) {
            await this._mergeDependency('service-instance', 'xsuaa')
        }
        if (addHana || addMultitenancy) {
            if (hasMultitenancy) {
                await this._mergeDependency('service-instance', 'service-manager')
            } else {
                await this._mergeDependency('service-instance', 'hana')
                await this._mergeDependency('content-deployment', 'hana-deployer')
            }
        }
        if (addKafka) {
            await this._mergeDependency('service-instance', 'kafka')
        }
        if (addPortal) {
            await this._mergeDependency('service-instance', 'portal')
            await this._mergeDependency('content-deployment', 'portal-deployer')
        }
        if (addMalwareScanner) {
            await this._mergeDependency('service-instance', 'malware-scanner')
        }
        if (addCloudLogging) {
            await this._mergeDependency('service-instance', 'cloud-logging')
        }
        if (addDynatrace) {
            await this._mergeDependency('service-instance', 'dynatrace')
        }
        if (addAuditLogging) {
            await this._mergeDependency('service-instance', 'auditlog')
        }
    }

    async _mergeDependency(name, alias) {
        const project = readProject()
        await merge({
            dependencies: [{
                name,
                alias,
                version: '>0.0.0'
            }]
        }).into('chart/Chart.yaml', {
            project,
            additions: [{
                in: 'dependencies',
                where: { alias }
            }]
        })
    }
}
